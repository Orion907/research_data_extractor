import os

# --- Helper function for ignoring paths (Moved to global scope) ---
def should_ignore(name, path, is_dir, ignore_patterns):
    """
    Checks if a path (file or directory) should be ignored based on a list of patterns.
    """
    # Normalize path to use forward slashes for consistent matching
    path = path.replace(os.sep, '/')
    
    for pattern in ignore_patterns:
        # Exact name match (e.g., '__pycache__')
        if name == pattern:
            return True
        # Starts with pattern (e.g., 'debug_*.py')
        if pattern.endswith('*') and name.startswith(pattern.rstrip('*')):
            return True
        # Ends with pattern (e.g., '*.pyc')
        if pattern.startswith('*') and name.endswith(pattern.lstrip('*')):
            return True
        
        # Directory specific pattern (e.g., 'temp/')
        # This checks if the name matches the pattern with a trailing slash removed, AND it's a directory
        if pattern.endswith('/') and is_dir and name == pattern.rstrip('/'):
            return True
            
    return False

# --- Tree Generation Function (Recursive for proper drawing) ---
def generate_tree_string(startpath, max_depth, ignore_patterns):
    """
    Generates a tree-like string representation of a directory,
    with specified depth limit and ignore patterns.
    """
    tree_lines = []
    
    def _build_tree_recursive(current_dir, current_prefix, current_depth):
        lines = []
        
        if current_depth > max_depth:
            return [] # Stop recursing if max_depth is exceeded

        all_entries = []
        try:
            for entry in os.listdir(current_dir):
                entry_path = os.path.join(current_dir, entry)
                is_dir = os.path.isdir(entry_path)
                
                # Use the global should_ignore function, passing the specific ignore_patterns
                if not should_ignore(entry, entry_path, is_dir, ignore_patterns):
                    all_entries.append((entry, is_dir))
        except OSError: 
            # print(f"Warning: Could not list directory {current_dir} (permission denied or invalid). Skipping.")
            return []

        all_entries.sort() # Sort alphabetically for consistent output

        for i, (name, is_dir) in enumerate(all_entries):
            is_last = (i == len(all_entries) - 1)
            
            line_char = "└── " if is_last else "├── "
            
            display_name = name
            if is_dir:
                display_name += '/' # Append slash for directories

            lines.append(f"{current_prefix}{line_char}{display_name}")

            if is_dir and current_depth < max_depth: # Recurse only if it's a directory and within depth limit
                next_prefix = current_prefix + ("    " if is_last else "│   ")
                lines.extend(_build_tree_recursive(os.path.join(current_dir, name), next_prefix, current_depth + 1))
        return lines

    # Start the recursive building from the base path
    tree_lines.append(".") # The root of the segment
    tree_lines.extend(_build_tree_recursive(startpath, "", 0)) # Initial call with no prefix, depth 0

    return "\n".join(tree_lines)


# --- Configuration ---
# Assumes script is in project root
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__)) 
OUTPUT_FILE = os.path.join(PROJECT_ROOT, "project_structure.md")

# --- Define Global Ignore Patterns ---
# These patterns are applied to the name of the file/directory.
COMMON_IGNORE_PATTERNS = [
    '__pycache__', '*.pyc', '*.pyo', '*.pyd', '*.class', # Python bytecode
    'node_modules', 'build', 'dist', '.git', '.vscode', '.idea', # Common dev/IDE folders
    '*.zip', '*.tar.gz', '*.sqlite', '*.db', # Archives/databases
    '.env', '.gitignore', '.Python', 'venv', 'env', 'data_ext_env', # Environment files/folders
    '*.tmp', '*.bak', '*.swp', '*.swo', # Temp/backup files
    '.DS_Store', 'Thumbs.db', # OS specific
    '*.log', # Log files
    'temp', # General temporary directory name
    'debug_*.py', 'direct_*.py', 'test_debug.py', # Specific debug/temporary python scripts
    # The specific problematic file
    "ioning (not complete)", # Note: exact literal name from `ls -b` if it had escaped chars
    
    # Files generated by this script itself (avoid including them in the tree output)
    'generate_project_structure.py',
    'project_structure.md', 
]

# Specific ignore patterns for SRC (inherits common)
SRC_IGNORE_PATTERNS = COMMON_IGNORE_PATTERNS + [
    # Add any specific files/folders within src you want to hide beyond common ones
]

# Specific ignore patterns for TESTS (inherits common)
TESTS_IGNORE_PATTERNS = COMMON_IGNORE_PATTERNS + [
    # Explicitly ignore common test output/temp directories IF they aren't caught by data/output/
    'output/', # If tests have their own specific 'output' dir not under data/output
    'chunks/', # If test creates chunks not under data/output
    # Any other specific test-related temporary files/folders not covered by common or data/output
]

# --- Main Script Logic ---
if __name__ == "__main__":
    markdown_content = []

    markdown_content.append("# Project Structure: Research Data Extractor (For AI Code Assistants)")
    markdown_content.append("")
    markdown_content.append("This document provides a concise and accurate overview of the `research_data_extractor` project's file and directory structure. Its primary purpose is to facilitate efficient code analysis and interaction by AI code assistants like Claude.")
    markdown_content.append("")
    markdown_content.append("## Top-Level Directory Overview")
    markdown_content.append("")
    markdown_content.append("```plaintext")
    
    # Define how each known top-level folder/file should be presented with comments
    # This list allows us to add specific descriptions for Claude
    # Files/folders not in this list will still be included if not in ROOT_LEVEL_IGNORE_PATTERNS below.
    custom_root_mapping = {
        "analytics/": " # Generated analytics reports (CSV, JSON)",
        "config/": " # Application configuration files (YAML)",
        "data/": " # Data assets (input, output, domain profiles)",
        "examples/": " # Example usage scripts",
        "prompts/": " # LLM prompt templates (JSON files, versioned)",
        "scripts/": " # Utility and automation scripts",
        "src/": " # Main application source code (detailed below)",
        "tests/": " # Test suites (detailed below)",
        ".env.example": " # Environment variable template",
        "main.py": " # Primary application entry point",
        "requirements.txt": " # Python package dependencies",
        "setup.py": " # Project packaging configuration",
        "simple_app.py": " # Simplified application example",
        "streamlit_app.py": " # Streamlit web application entry point",
        "README.md": "", 
        "project_info.md": "",
        "project_structure.md": "" 
    }

    # Custom ignore patterns for the ROOT LEVEL ONLY, as some common ignores might be desired
    # to be *listed* at the root (like .gitignore, .env.example) but ignored deeper.
    # Here, we only exclude items that we *never* want to appear at the root level,
    # or that we want to manually represent with custom comments via custom_root_mapping.
    ROOT_LEVEL_IGNORE_PATTERNS = [
        '__pycache__', '*.pyc', '*.pyo', '*.pyd', '*.class', # Python bytecode
        'node_modules', 'build', 'dist', '.git', '.vscode', '.idea', # Common dev/IDE folders
        '*.zip', '*.tar.gz', '*.sqlite', '*.db', # Archives/databases
        'venv', 'env', 'data_ext_env', # Virtual env folders (often not at root, but just in case)
        '*.tmp', '*.bak', '*.swp', '*.swo', # Temp/backup files
        '.DS_Store', 'Thumbs.db', # OS specific
        '*.log', # General log files
        'temp', # General temporary directory name
        "ioning (not complete)", # The problematic file (assuming you deleted it already via rm)
        'generate_project_structure.py', # The script itself
        'project_structure.md', # The output file itself
        # NOTE: .env, .env.example, .gitignore, README.md, etc. are *not* in this ignore list
        # so they will be included in the auto-generated part of the root tree.
    ]

    # Get all entries at the project root level
    root_entries = []
    try:
        for entry in os.listdir(PROJECT_ROOT):
            entry_path = os.path.join(PROJECT_ROOT, entry)
            is_dir = os.path.isdir(entry_path)
            
            # Use ROOT_LEVEL_IGNORE_PATTERNS for the top-level filtering
            if not should_ignore(entry, entry_path, is_dir, ROOT_LEVEL_IGNORE_PATTERNS):
                root_entries.append((entry, is_dir))
    except OSError as e:
        markdown_content.append(f"Error listing root directory: {e}")
        root_entries = [] # Clear entries if error

    root_entries.sort() # Sort alphabetically

    # Add the sorted top-level items to the tree lines, applying custom comments
    tree_root_lines = []
    tree_root_lines.append(".") # The overall project root
    for i, (name, is_dir) in enumerate(root_entries):
        line_char = "└── " if i == len(root_entries) - 1 else "├── "
        display_name = name + ('/' if is_dir else '')
        comment = custom_root_mapping.get(display_name, "")
        tree_root_lines.append(f"{line_char}{display_name}{comment}")
            
    markdown_content.append("\n".join(tree_root_lines))
    markdown_content.append("```")
    markdown_content.append("")
    markdown_content.append("**Note:** Temporary files, build artifacts, and `__pycache__` directories are omitted for clarity and efficiency.")
    markdown_content.append("")

    # --- Generate src Tree ---
    src_max_depth = 4 # Adjust as needed
    markdown_content.append("## `src` Directory: Core Application Logic")
    markdown_content.append("")
    markdown_content.append("```plaintext")
    markdown_content.append(generate_tree_string(os.path.join(PROJECT_ROOT, "src"), src_max_depth, SRC_IGNORE_PATTERNS))
    markdown_content.append("```")
    markdown_content.append("")

    # --- Generate tests Tree ---
    tests_max_depth = 3 # Adjust as needed
    markdown_content.append("## `tests` Directory: Test Suites")
    markdown_content.append("")
    markdown_content.append("```plaintext")
    markdown_content.append(generate_tree_string(os.path.join(PROJECT_ROOT, "tests"), tests_max_depth, TESTS_IGNORE_PATTERNS))
    markdown_content.append("```")
    markdown_content.append("")

    # --- Write to file ---
    try:
        with open(OUTPUT_FILE, "w") as f:
            f.write("\n".join(markdown_content))
        print(f"Successfully generated {OUTPUT_FILE}")
    except IOError as e:
        print(f"Error writing to file {OUTPUT_FILE}: {e}")